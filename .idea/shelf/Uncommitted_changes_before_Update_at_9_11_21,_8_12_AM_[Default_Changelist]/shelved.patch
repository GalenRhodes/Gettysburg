Index: Sources/Gettysburg/Misc/Extensions.swift
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/************************************************************************//**\n *     PROJECT: Gettysburg\n *    FILENAME: Extensions.swift\n *         IDE: AppCode\n *      AUTHOR: Galen Rhodes\n *        DATE: 2/16/21\n *\n * Copyright Â© 2021 Galen Rhodes. All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *//************************************************************************/\n\nimport Foundation\nimport CoreFoundation\nimport Rubicon\n\npublic let PCDATA: String = \"#PCDATA\"\n\nextension SAXExternalType: CustomStringConvertible {\n    @inlinable public var description: String {\n        switch self {\n            case .Internal: return \"\"\n            case .Public:   return \"PUBLIC\"\n            case .System:   return \"SYSTEM\"\n        }\n    }\n\n    @inlinable public static func valueFor(description desc: String?) -> SAXExternalType {\n        switch desc {\n            case \"SYSTEM\": return .System\n            case \"PUBLIC\": return .Public\n            case nil:      return .Public\n            default:       return .Internal\n        }\n    }\n}\n\nextension SAXAttributeDefaultType: CustomStringConvertible {\n    @inlinable public var description: String {\n        switch self {\n            case .Value:    return \"\"\n            case .Required: return \"#Required\"\n            case .Implied:  return \"#Implied\"\n            case .Fixed:    return \"#Fixed\"\n        }\n    }\n\n    @inlinable public static func valueFor(description desc: String) -> SAXAttributeDefaultType {\n        switch desc {\n            case \"#REQUIRED\": return .Required\n            case \"#FIXED\":    return .Fixed\n            case \"#IMPLIED\":  return .Implied\n            default:          return .Value\n        }\n    }\n}\n\nextension SAXAttributeType: CustomStringConvertible {\n    @inlinable public var description: String {\n        switch self {\n            case .CData:      return \"CData\"\n            case .ID:         return \"ID\"\n            case .IDRef:      return \"IDRef\"\n            case .IDRefs:     return \"IDRefs\"\n            case .Entity:     return \"Entity\"\n            case .Entities:   return \"Entities\"\n            case .NMToken:    return \"NMToken\"\n            case .NMTokens:   return \"NMTokens\"\n            case .Notation:   return \"Notation\"\n            case .Enumerated: return \"()\"\n        }\n    }\n\n    @inlinable public static func valueFor(description desc: String?) -> SAXAttributeType? {\n        guard let desc = desc else { return nil }\n        switch desc {\n            case \"CDATA\":    return .CData\n            case \"ID\":       return .ID\n            case \"IDREF\":    return .IDRef\n            case \"IDREFS\":   return .IDRefs\n            case \"ENTITY\":   return .Entity\n            case \"ENTITIES\": return .Entities\n            case \"NMTOKEN\":  return .NMToken\n            case \"NMTOKENS\": return .NMTokens\n            case \"NOTATION\": return .Notation\n            default:         return ((desc.hasPrefix(\"(\") && desc.hasSuffix(\")\")) ? .Enumerated : nil)\n        }\n    }\n\n    @inlinable public func enumList(_ str: String) -> [String] {\n        guard self == .Enumerated else { return [] }\n        guard str.count > 1 && str[str.startIndex] == \"(\" && str[str.lastIndex!] == \")\" else { return [] }\n        return str.firstLastRemoved().components(separatedBy: CharacterSet(charactersIn: \"|\"))\n    }\n}\n\nextension SAXEntityType: CustomStringConvertible {\n    @inlinable public var description: String {\n        switch self {\n            case .General:   return \"General\"\n            case .Parameter: return \"Parameter\"\n            case .Unparsed:  return \"Unparsed\"\n        }\n    }\n\n    @inlinable public static func valueFor(description desc: String) -> SAXEntityType {\n        switch desc {\n            case \"General\":   return .General\n            case \"Parameter\": return .Parameter\n            default:          return .Unparsed\n        }\n    }\n}\n\nextension SAXElementAllowedContent: CustomStringConvertible {\n    @inlinable public var description: String {\n        switch self {\n            case .Any:      return \"Any\"\n            case .Empty:    return \"Empty\"\n            case .Elements: return \"Elements\"\n            case .Mixed:    return \"Mixed\"\n            case .PCData:   return \"#PCDATA\"\n        }\n    }\n\n    @inlinable public static func valueFor(description desc: String?) -> SAXElementAllowedContent {\n        if let d = desc {\n            switch d {\n                case \"ANY\":         return .Any\n                case \"EMPTY\":       return .Empty\n                case \"(\\(PCDATA))\": return .PCData\n                default:            return (d.hasPrefix(\"(\\(PCDATA)\") ? .Mixed : .Elements)\n            }\n        }\n        return .Empty\n    }\n}\n\nextension SAXDTDElemCont.ItemType: CustomStringConvertible {\n    @inlinable public var description: String {\n        switch self {\n            case .Element: return \"Element\"\n            case .List:    return \"List\"\n            case .PCData:  return \"PCData\"\n        }\n    }\n\n    @inlinable public static func valueFor(description desc: String) -> SAXDTDElemCont.ItemType {\n        switch desc {\n            case \"Element\": return .Element\n            case \"List\":    return .List\n            default:        return .PCData\n        }\n    }\n}\n\nextension SAXDTDElemCont.ItemMultiplicity: CustomStringConvertible {\n    @inlinable public var description: String {\n        switch self {\n            case .Optional:   return \"Optional\"\n            case .Once:       return \"Once\"\n            case .ZeroOrMore: return \"ZeroOrMore\"\n            case .OneOrMore:  return \"OneOrMore\"\n        }\n    }\n\n    @inlinable public var symbolChar: String {\n        switch self {\n            case .Optional:   return \"?\"\n            case .Once:       return \"\"\n            case .ZeroOrMore: return \"*\"\n            case .OneOrMore:  return \"+\"\n        }\n    }\n\n    @inlinable public static func valueFor(char: Character?) -> SAXDTDElemCont.ItemMultiplicity {\n        guard let char = char else { return .Once }\n        switch char {\n            case \"?\": return .Optional\n            case \"+\": return .OneOrMore\n            case \"*\": return .ZeroOrMore\n            default:  return .Once\n        }\n    }\n}\n\nextension SAXDTDElemContList.ItemConjunction: CustomStringConvertible {\n    @inlinable public var description: String {\n        switch self {\n            case .And: return \"And\"\n            case .Or:  return \"Or\"\n        }\n    }\n\n    @inlinable public static func valueFor(description desc: String) -> SAXDTDElemContList.ItemConjunction {\n        switch desc {\n            case \"And\": return .And\n            default:    return .Or\n        }\n    }\n}\n\nextension StringProtocol {\n    @inlinable public func firstLastRemoved() -> String {\n        guard count > 2 else { return \"\" }\n        return String(self[index(after: startIndex) ..< lastIndex!])\n    }\n\n    @inlinable public func deQuoted() -> String {\n        guard count > 1 else { return String(self) }\n        let ch = self[startIndex]\n        guard value(ch, isOneOf: \"\\\"\", \"'\") else { return String(self) }\n        let ei = lastIndex!\n        guard self[ei] == ch else { return String(self) }\n        return String(self[index(after: startIndex) ..< ei])\n    }\n\n    @discardableResult @inlinable public func advance(index idx: inout String.Index, position pos: inout TextPosition) -> Bool {\n        guard idx < endIndex else { return false }\n        textPositionUpdate(self[idx], pos: &pos, tabWidth: 4)\n        formIndex(after: &idx)\n        return (idx < endIndex)\n    }\n\n    @inlinable public var isValidXMLName: Bool {\n        guard count > 0 else { return false }\n        guard self[startIndex].isXmlNameStartChar else { return false }\n        var idx = index(after: startIndex)\n        while idx < endIndex {\n            guard self[idx].isXmlNameChar else { return false }\n            formIndex(after: &idx)\n        }\n        return true\n    }\n}\n\nextension String {\n\n    @inlinable public var isTrimmedNotEmpty: Bool { self.trimmed.isNotEmpty }\n    @inlinable public var isTrimmedEmpty:    Bool { self.trimmed.isEmpty }\n\n    /*===========================================================================================================================================================================*/\n    /// Assuming this string is a fully qualified name, return a tuple containing the prefix and local name from this string.\n    ///\n    /// - Returns: the prefix and local name.  `nil` is returned for the prefix if none is found.\n    ///\n    @inlinable public func splitPrefix() -> (String?, String) {\n        guard let idx = firstIndex(of: \":\") else { return (nil, self) }\n        guard idx > startIndex else { return (nil, String(self[index(after: startIndex) ..< endIndex])) }\n        return (String(self[startIndex ..< idx]), String(self[index(after: idx) ..< endIndex]))\n    }\n\n    @inlinable public func encodeEntities() -> String {\n        var out: String = \"\"\n        for ch in self {\n            switch ch {\n                case \"<\":  out.append(\"&lt;\")\n                case \">\":  out.append(\"&gt;\")\n                case \"\\\"\": out.append(\"&quot;\")\n                case \"'\":  out.append(\"&apos;\")\n                case \"&\":  out.append(\"&amp;\")\n                default:   out.append(ch)\n            }\n        }\n        return out\n    }\n}\n\nextension Collection where Element == Character {\n\n    @inlinable public func lowercased() -> [Character] {\n        var out: [Character] = []\n        forEach { out.append(contentsOf: $0.lowercased()) }\n        return out\n    }\n}\n
===================================================================
diff --git a/Sources/Gettysburg/Misc/Extensions.swift b/Sources/Gettysburg/Misc/Extensions.swift
--- a/Sources/Gettysburg/Misc/Extensions.swift	
+++ b/Sources/Gettysburg/Misc/Extensions.swift	
@@ -227,8 +227,20 @@
 
     @discardableResult @inlinable public func advance(index idx: inout String.Index, position pos: inout TextPosition) -> Bool {
         guard idx < endIndex else { return false }
+
+        let c0 = self[idx]
+        nDebug(.In, "Index Before: \(c0) (\(pos.lineNumber), \(pos.columnNumber))")
+
         textPositionUpdate(self[idx], pos: &pos, tabWidth: 4)
         formIndex(after: &idx)
+
+        if idx < endIndex {
+            nDebug(.Out, "Index Before: \(self[idx]) (\(pos.lineNumber), \(pos.columnNumber))")
+        }
+        else {
+            nDebug(.Out, "Index Before: ðŸš« (\(pos.lineNumber), \(pos.columnNumber))")
+        }
+
         return (idx < endIndex)
     }
 
Index: Sources/Gettysburg/Misc/Tools.swift
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/************************************************************************//**\n *     PROJECT: Gettysburg\n *    FILENAME: Tools.swift\n *         IDE: AppCode\n *      AUTHOR: Galen Rhodes\n *        DATE: 2/16/21\n *\n * Copyright Â© 2021 Galen Rhodes. All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *//************************************************************************/\n\nimport Foundation\nimport CoreFoundation\nimport Rubicon\n\n/*===============================================================================================================================================================================*/\n/// Get a URL for the current working directory.\n///\n/// - Returns: the current working directory as a URL.\n///\n@inlinable func GetCurrDirURL() -> URL { URL(fileURLWithPath: FileManager.default.currentDirectoryPath, isDirectory: true) }\n\n/*===============================================================================================================================================================================*/\n/// Get a URL for the given filename.  If the filename is relative it will be made absolute relative to the current working directory.\n///\n/// - Parameter filename: the filename.\n/// - Returns: the filename as an absolute URL.\n///\n@inlinable func GetFileURL(filename: String) -> URL { URL(fileURLWithPath: filename, relativeTo: GetCurrDirURL()) }\n\n/*===============================================================================================================================================================================*/\n/// Get a `URL` for it's given string form. The difference between this function and calling the <code>[foundation class\n/// URL's](https://developer.apple.com/documentation/foundation/url)</code> constructor\n/// <code>[`URL(string:)`](https://developer.apple.com/documentation/foundation/url/3126806-init)</code> is that this function will throw an error if the URL is malformed rather\n/// than returning `nil` and if the URL is relative and `nil` is passed for the `relativeTo` base URL then it will use the current working directory.\n///\n/// - Parameters:\n///   - string: the string containing the URL.\n///   - relativeTo: If the URL defined by the given string is relative then...\n/// - Returns: the URL.\n/// - Throws: if the URL is malformed.\n///\n@inlinable func GetURL(string: String, relativeTo: URL? = nil) throws -> URL {\n    guard let url = URL(string: string, relativeTo: (relativeTo ?? GetCurrDirURL())) else { throw SAXError.getMalformedURL(description: string) }\n    return url\n}\n\n/*===============================================================================================================================================================================*/\n/// Print out an array of strings to STDOUT. Used for debugging.\n///\n/// - Parameter strings: the array of strings.\n///\n@usableFromInline func PrintArray(_ strings: [String?]) {\n    #if DEBUG\n        var idx = 0\n        for s in strings {\n            if let s = s { print(\"\\(idx++)> \\\"\\(s)\\\"\") }\n            else { print(\"\\(idx++)> NIL\") }\n        }\n    #endif\n}\n\n/*===============================================================================================================================================================================*/\n/// Given a URL, get the Base URL and the filename.\n///\n/// - Parameter url: the URL.\n/// - Returns: a tuple with the given URL, the Base URL, and the filename. If the given URL was relative then it is made absolute with respect to the current working directory.\n/// - Throws: if the URL is malformed.\n///\n@inlinable func GetBaseURLAndFilename(url: URL) throws -> (URL, URL, String) {\n    let burl     = try GetURL(string: url.absoluteString)\n    let baseURL  = burl.deletingLastPathComponent()\n    let filename = burl.lastPathComponent\n    return (burl, baseURL, filename)\n}\n\nlet UTF32BEBOM: [UInt8] = [ 0, 0, 0xfe, 0xff ]\nlet UTF32LEBOM: [UInt8] = [ 0xff, 0xfe, 0, 0 ]\nlet UTF16BEBOM: [UInt8] = [ 0xfe, 0xff ]\nlet UTF16LEBOM: [UInt8] = [ 0xff, 0xfe ]\nlet UTF8BOM:    [UInt8] = [ 0xef, 0xbb, 0xbf ]\n\n/*===============================================================================================================================================================================*/\n/// Determin the encoding used in a file by sampling the bytes and/or reading the XML Declaration.\n///\n/// - Parameter inputStream: The MarkInputStream.\n/// - Returns: The encoding name.\n/// - Throws: If an  I/O error occurs or the encoding is not supported.\n///\n@usableFromInline func getEncodingName(inputStream: MarkInputStream) throws -> String {\n    nDebug(.In, \"Mark Count: \\(inputStream.markCount)\")\n    defer { nDebug(.Out, \"Mark Count: \\(inputStream.markCount)\") }\n    return try _getEncodingName(inputStream: inputStream)\n}\n\n@usableFromInline func _getEncodingName(inputStream: MarkInputStream) throws -> String {\n    var buffer: [UInt8] = [ 0, 0, 0, 0 ]\n\n    inputStream.open()\n    inputStream.markSet()\n    defer { inputStream.markReturn() }\n    guard inputStream.read(&buffer, maxLength: 4) == 4 else { throw SAXError.getUnexpectedEndOfInput(description: \"Not enough data to determine the character encoding.\") }\n\n    if buffer == UTF32BEBOM {\n        inputStream.markUpdate()\n        return \"UTF-32BE\"\n    }\n    else if buffer == UTF32LEBOM {\n        inputStream.markUpdate()\n        return \"UTF-32LE\"\n    }\n    else if buffer[0 ..< 2] == UTF16BEBOM {\n        inputStream.markUpdate()\n        return \"UTF-16BE\"\n    }\n    else if buffer[0 ..< 2] == UTF16LEBOM {\n        inputStream.markUpdate()\n        return \"UTF-16LE\"\n    }\n    else if buffer[0 ..< 3] == UTF8BOM {\n        inputStream.markUpdate()\n        return \"UTF-8\"\n    }\n    else {\n        inputStream.markReset()\n        return try hardGuess(guessEncodingName(buffer), inputStream)\n    }\n}\n\n@usableFromInline func hardGuess(_ encodingName: String, _ inputStream: MarkInputStream) throws -> String {\n    // NOTE: At this point the encoding is only guessed at.  We'll need to look for an XML Declaration element to hopefully give us more information.\n    nDebug(.None, \"Taking a hard guess starting out with: \\\"\\(encodingName)\\\"\")\n    let _inputStream = SimpleIConvCharInputStream(inputStream: inputStream, encodingName: encodingName, autoClose: false)\n    nDebug(.None, \"Create SimpleIConvCharInputStream...\")\n    _inputStream.open()\n    nDebug(.None, \"Opened SimpleIConvCharInputStream...\")\n    defer { _inputStream.close() }\n\n    var chars: [Character] = []\n    nDebug(.None, \"Attempting to read the first 6 characters.\")\n    guard try _inputStream.read(chars: &chars, maxLength: 6) == 6 else { return encodingName }\n    nDebug(.None, \"Read the first 6 characters: \\\"\\(String(chars))\\\"\")\n    guard chars.matches(pattern: \"<\\\\?(?i:xml)\\\\s\") else { return encodingName }\n\n    // We have an XML Declaration element.  Read it, parse it, determine the encoding.\n    repeat {\n        guard let _ch = try _inputStream.read() else { return encodingName }\n        chars <+ _ch\n        if _ch == \">\" {\n            guard chars[chars.endIndex - 2] == \"?\" else { return encodingName }\n            break\n        }\n    } while true\n\n    // Now let's see if it contains the encoding.\n    let decl = String(chars)\n    nDebug(.None, \"XML Decl: \\\"\\(decl)\\\"\")\n    guard let m = GetRegularExpression(pattern: \"\\\\sencoding=\\\"([^\\\"]+)\\\"\").firstMatch(in: decl), let enc = m[1].subString else { return encodingName }\n    // We definitely got an encoding name, now let's see if we support it.\n    let uEnc = enc.uppercased()\n    guard IConv.encodingsList.contains(uEnc) else { throw SAXError.getUnknownEncoding(description: \"Uknown encoding: \\(enc)\") }\n    return uEnc\n}\n\n@usableFromInline func guessEncodingName(_ buffer: [UInt8]) -> String {\n    if (buffer[0] == 0 && buffer[1] != 0) || (buffer[2] == 0 && buffer[3] != 0) { return \"UTF-16BE\" }\n    else if (buffer[0] != 0 && buffer[1] == 0) || (buffer[2] != 0 && buffer[3] == 0) { return \"UTF-16LE\" }\n    else if (buffer[0] == 0 && buffer[1] == 0 && buffer[3] != 0) { return \"UTF-32BE\" }\n    else if (buffer[0] != 0 && buffer[2] == 0 && buffer[3] == 0) { return \"UTF-32LE\" }\n    else { return \"UTF-8\" }\n}\n\n@usableFromInline struct ItemStore<T> {\n    @usableFromInline var items: [String: T]   = [:]\n    @usableFromInline let lock:  ReadWriteLock = ReadWriteLock()\n\n    init() {}\n\n    @inlinable subscript(key: String) -> T? {\n        get { lock.withReadLock { items[key] } }\n        set { lock.withWriteLock { items[key] = newValue } }\n    }\n}\n\n@usableFromInline var regexStore: ItemStore<RegularExpression> = ItemStore<RegularExpression>()\n\nextension RegularExpression.Options {\n    @inlinable var name: Character {\n        switch self {\n            case .caseInsensitive:            return \"i\"\n            case .allowCommentsAndWhitespace: return \"x\"\n            case .dotMatchesLineSeparators:   return \"s\"\n            case .anchorsMatchLines:          return \"m\"\n            case .useUnicodeWordBoundaries:   return \"w\"\n            case .ignoreMetacharacters:       return \"c\"\n            case .useUnixLineSeparators:      return \"u\"\n        }\n    }\n\n    @inlinable static func optionsString(_ options: [Self]) -> String {\n        var out: String = \"(\"\n        for o in options { out.append(o.name) }\n        out.append(\")\")\n        return out\n    }\n}\n\n@inlinable func GetRegularExpression(pattern: String, options: [RegularExpression.Options] = []) -> RegularExpression {\n    let key = \"\\(RegularExpression.Options.optionsString(options))Ã\\(pattern)\"\n    if let rx = regexStore[key] { return rx }\n    var err: Error? = nil\n    guard let rx = RegularExpression(pattern: pattern, options: options, error: &err) else { fatalError(\"Invalid REGEX Pattern: \\(err!.localizedDescription)\") }\n    regexStore[key] = rx\n    return rx\n}\n\nextension Array where Element == Character {\n\n    @inlinable public func matches(pattern: String) -> Bool {\n        let str: String                    = String(self)\n        let m:   [RegularExpression.Match] = GetRegularExpression(pattern: pattern).matches(in: str)\n        return ((m.count == 1) && (str.fullRange == m[0].range))\n    }\n}\n\n@inlinable func GetExternalFile(parentStream: SAXCharInputStream, url: URL) throws -> String { try GetExternalFile(position: parentStream.position, url: url) }\n\n@usableFromInline func GetExternalFile(position: TextPosition = (0, 0), url: URL) throws -> String {\n    guard let byteInputStream = InputStream(url: url) else { throw SAXError.MalformedURL(position: position, description: url.absoluteString) }\n    let charInputStream = try SAXIConvCharInputStream(inputStream: byteInputStream, url: url)\n    var buffer: [Character] = []\n    _ = try charInputStream.read(chars: &buffer, maxLength: Int.max)\n    return String(buffer)\n}\n\n@inlinable func GetPosition(from str: String, range: Range<String.Index>, startingAt pos: TextPosition) -> TextPosition {\n    var p = pos\n    str[range].forEach { ch in textPositionUpdate(ch, pos: &p, tabWidth: 4) }\n    return p\n}\n\n@inlinable func AdvancePosition(from str: String, range: Range<String.Index>, position pos: inout TextPosition) { pos = GetPosition(from: str, range: range, startingAt: pos) }\n
===================================================================
diff --git a/Sources/Gettysburg/Misc/Tools.swift b/Sources/Gettysburg/Misc/Tools.swift
--- a/Sources/Gettysburg/Misc/Tools.swift	
+++ b/Sources/Gettysburg/Misc/Tools.swift	
@@ -251,3 +251,6 @@
 }
 
 @inlinable func AdvancePosition(from str: String, range: Range<String.Index>, position pos: inout TextPosition) { pos = GetPosition(from: str, range: range, startingAt: pos) }
+
+@inlinable func posstr(_ p: TextPosition) -> String { "(\(p.lineNumber), \(p.columnNumber))" }
+
Index: Sources/Gettysburg/DOM/DocType/SAXDTDElemCont.swift
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*******************************************************************************************************************************************************************************//*\n *     PROJECT: Gettysburg\n *    FILENAME: SAXDTDElementContentItem.swift\n *         IDE: AppCode\n *      AUTHOR: Galen Rhodes\n *        DATE: 6/1/21\n *\n * Copyright Â© 2021 Galen Rhodes. All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this\n * permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO\n * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\n * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *//******************************************************************************************************************************************************************************/\n\nimport Foundation\nimport CoreFoundation\nimport Rubicon\n\nfunc ParseDTDElementContentList(position pos: TextPosition, list src: String) throws -> SAXDTDElemContList {\n    var idx: String.Index = src.startIndex\n    var pos: TextPosition = pos\n    return try _parseDTDElementContentList(isRoot: true, list: src, startIndex: &idx, position: &pos)\n}\n\npublic class SAXDTDElemCont: Hashable {\n    public enum ItemMultiplicity { case Optional, Once, ZeroOrMore, OneOrMore }\n\n    public enum ItemType { case Element, List, PCData }\n\n    public let type:         ItemType\n    public let multiplicity: ItemMultiplicity\n\n    public init(type: ItemType, multiplicity: ItemMultiplicity) {\n        self.type = type\n        self.multiplicity = multiplicity\n    }\n\n    public func hash(into hasher: inout Hasher) {\n        hasher.combine(type)\n        hasher.combine(multiplicity)\n    }\n\n    @inlinable public static func == (lhs: SAXDTDElemCont, rhs: SAXDTDElemCont) -> Bool { equals(lhs: lhs, rhs: rhs) }\n\n    @inlinable static func equals(lhs: SAXDTDElemCont, rhs: SAXDTDElemCont) -> Bool {\n        ((Swift.type(of: lhs) == Swift.type(of: rhs)) && (lhs.type == rhs.type) && (lhs.multiplicity == rhs.multiplicity))\n    }\n}\n\npublic class SAXDTDElemContList: SAXDTDElemCont {\n    public enum ItemConjunction { case And, Or }\n\n    public let conjunction: ItemConjunction\n    public var items:       [SAXDTDElemCont] = []\n\n    public init(multiplicity: ItemMultiplicity, conjunction: ItemConjunction, items: [SAXDTDElemCont] = []) {\n        self.conjunction = conjunction\n        super.init(type: .List, multiplicity: multiplicity)\n        self.items.append(contentsOf: items)\n    }\n\n    @inlinable public static func <+ (lhs: SAXDTDElemContList, rhs: SAXDTDElemCont) { lhs.items <+ rhs }\n\n    @inlinable public static func <+ (lhs: SAXDTDElemContList, rhs: [SAXDTDElemCont]) { lhs.items.append(contentsOf: rhs) }\n\n    @inlinable public static func == (lhs: SAXDTDElemContList, rhs: SAXDTDElemContList) -> Bool {\n        (equals(lhs: lhs, rhs: rhs) && (lhs.conjunction == rhs.conjunction) && (lhs.items == rhs.items))\n    }\n}\n\npublic class SAXDTDElemContElement: SAXDTDElemCont {\n    public let name: String\n\n    public init(name: String, multiplicity: ItemMultiplicity) {\n        self.name = name\n        super.init(type: .Element, multiplicity: multiplicity)\n    }\n\n    public override func hash(into hasher: inout Hasher) {\n        super.hash(into: &hasher)\n        hasher.combine(name)\n    }\n\n    public static func == (lhs: SAXDTDElemContElement, rhs: SAXDTDElemContElement) -> Bool { (equals(lhs: lhs, rhs: rhs) && (lhs.name == rhs.name)) }\n}\n\npublic class SAXDTDElemContPCData: SAXDTDElemCont {\n    public convenience init() { self.init(type: .PCData, multiplicity: .Optional) }\n}\n\nfileprivate func _parseDTDElementContentList(isRoot: Bool, list src: String, startIndex idx: inout String.Index, position pos: inout TextPosition) throws -> SAXDTDElemContList {\n    // The first character needs to be \"(\"!\n    guard src[idx] == \"(\" else { throw SAXError.MalformedElementDecl(position: pos, description: _msg(msg: \"Not an allowed content list or sublist\", expected: \"(\", got: src[idx])) }\n\n    // And it can't be the last character.\n    try nextPos(list: src, startIndex: &idx, position: &pos)\n\n    var arr: [SAXDTDElemCont] = []\n\n    // Is this an empty list?\n    let ch1                   = src[idx]\n    guard ch1 != \")\" else {\n        return SAXDTDElemContList(multiplicity: try _getMultiplicity(list: src, startIndex: &idx, position: &pos), conjunction: .And, items: arr)\n    }\n\n    // Parse the first item in the list.\n    arr <+ try _parseItem(pcDataAllowed: isRoot, list: src, startIndex: &idx, position: &pos)\n\n    // Get the next character which should be \")\", \",\", or \"|\".\n    let cChar: Character = src[idx]\n\n    // Are we done with our list?\n    if cChar != \")\" {\n        // If cChar wasn't a list closer, \")\", then it needs to be either \",\" or \"|\".\n        guard value(cChar, isOneOf: \",\", \"|\") else { throw SAXError.MalformedElementDecl(position: pos, description: _msg(msg: \"Not a valid combining character\", expected: \",\", \"|\", got: cChar)) }\n\n        // Keep parsing items as long as they are all separated by the same character.\n        repeat {\n            try nextPos(list: src, startIndex: &idx, position: &pos)\n            arr <+ try _parseItem(pcDataAllowed: false, list: src, startIndex: &idx, position: &pos)\n        } while src[idx] == cChar\n\n        // If the last character wasn't the same as the combining character then it better be the list closing character.\n        guard src[idx] == \")\" else { throw SAXError.MalformedElementDecl(position: pos, description: _msg(msg: \"Unexpected character\", expected: cChar, \")\", got: src[idx])) }\n    }\n\n    // Return our list.\n    return SAXDTDElemContList(multiplicity: try _getMultiplicity(list: src, startIndex: &idx, position: &pos), conjunction: ((cChar == \",\") ? .And : .Or), items: arr)\n}\n\nfileprivate func _parseItem(pcDataAllowed: Bool, list src: String, startIndex idx: inout String.Index, position pos: inout TextPosition) throws -> SAXDTDElemCont {\n    let ch = src[idx]\n    if ch == \"(\" {\n        return try _parseDTDElementContentList(isRoot: false, list: src, startIndex: &idx, position: &pos)\n    }\n    else {\n        let (item, m, p) = try _getElement(list: src, position: &pos, startIndex: &idx)\n\n        if item.first == \"#\" {\n            guard item == PCDATA else { throw SAXError.MalformedElementDecl(position: p, description: \"Unknown metaitem: \\\"\\(item)\\\"\") }\n            guard pcDataAllowed else { throw SAXError.MalformedElementDecl(position: p, description: \"\\(PCDATA) not allowed here.\") }\n            guard m == .Once else { throw SAXError.MalformedElementDecl(position: p, description: \"\\(PCDATA) cannot have a multiplicity character: \\(m)\") }\n            return SAXDTDElemContPCData()\n        }\n        else {\n            guard item.isValidXMLName else { throw SAXError.MalformedElementDecl(position: p, description: \"Not a valid XML name: \\\"\\(item)\\\"\") }\n            return SAXDTDElemContElement(name: item, multiplicity: m)\n        }\n    }\n}\n\nfileprivate func _getElement(list src: String, position pos: inout TextPosition, startIndex idx: inout String.Index) throws -> (String, SAXDTDElemCont.ItemMultiplicity, TextPosition) {\n    let p: TextPosition = pos\n    var b: [Character]  = []\n\n    while !value(src[idx], isOneOf: \"(\", \")\", \",\", \"|\", \"+\", \"?\", \"*\") {\n        b <+ src[idx]\n        try nextPos(list: src, startIndex: &idx, position: &pos)\n    }\n\n    let m = SAXDTDElemCont.ItemMultiplicity.valueFor(char: src[idx])\n    if m != .Once { try nextPos(list: src, startIndex: &idx, position: &pos) }\n    return (String(b), m, p)\n}\n\nfileprivate func nextPos(list src: String, startIndex idx: inout String.Index, position pos: inout TextPosition) throws {\n    var idx = idx\n    var pos = pos\n    guard src.advance(index: &idx, position: &pos) else { throw SAXError.MalformedElementDecl(position: pos, description: \"Unclosed content list.\") }\n}\n\nfileprivate func _getMultiplicity(list src: String, startIndex idx: inout String.Index, position pos: inout TextPosition) throws -> SAXDTDElemCont.ItemMultiplicity {\n    // Advance to the next character and see if we have a multiplicity character.\n    try nextPos(list: src, startIndex: &idx, position: &pos)\n    let m = SAXDTDElemCont.ItemMultiplicity.valueFor(char: src[idx])\n    if m != .Once { try nextPos(list: src, startIndex: &idx, position: &pos) }\n    return m\n}\n\nfileprivate func _msg(msg: String, expected c1: String..., got c2: String) -> String { __msg(msg: msg, expected: c1, got: c2) }\n\nfileprivate func _msg(msg: String, expected c1: Character..., got c2: Character) -> String { __msg(msg: msg, expected: c1.map { String($0) }, got: String(c2)) }\n\nfileprivate func __msg(msg: String, expected c1: [String], got c2: String) -> String {\n    let cc          = c1.count\n    var out: String = \"\\(msg) -\"\n\n    guard cc > 0 else { return \"\\(out) did not expect \\\"\\(c2)\\\".\" }\n\n    out += \"expected \\\"\\(c1[0])\\\"\"\n\n    if cc > 1 {\n        let x = (c1.endIndex - 1)\n        for i in (1 ..< x) { out += \", \\\"\\(c1[i])\\\"\" }\n        out += \", or \\\"\\(c1[x])\\\"\"\n    }\n\n    return \"\\(out) but got \\\"\\(c2)\\\" instead.\"\n}\n
===================================================================
diff --git a/Sources/Gettysburg/DOM/DocType/SAXDTDElemCont.swift b/Sources/Gettysburg/DOM/DocType/SAXDTDElemCont.swift
--- a/Sources/Gettysburg/DOM/DocType/SAXDTDElemCont.swift	
+++ b/Sources/Gettysburg/DOM/DocType/SAXDTDElemCont.swift	
@@ -167,8 +167,6 @@
 }
 
 fileprivate func nextPos(list src: String, startIndex idx: inout String.Index, position pos: inout TextPosition) throws {
-    var idx = idx
-    var pos = pos
     guard src.advance(index: &idx, position: &pos) else { throw SAXError.MalformedElementDecl(position: pos, description: "Unclosed content list.") }
 }
 
